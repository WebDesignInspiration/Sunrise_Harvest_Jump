<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Simple Jump Game</title>
<style>
  html,body{height:100%;margin:0;background:#0b1222;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:grid;place-items:center;height:100%}
  canvas{
    width:min(100vw,900px);
    height:min(70vh,520px);
    border-radius:14px;
    box-shadow:0 18px 50px rgba(0,0,0,.4);
    background:#bfe6ff; /* sky */
    touch-action:none;
  }
  .hud{position:absolute;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:10px;flex-wrap:wrap}
  .pill{background:#ffffffcc;border:2px solid #00000014;border-radius:999px;padding:6px 12px;font-weight:700}
  .btn{cursor:pointer}

  /* Modals */
  .modal{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.35);z-index:10}
  .modal.show{display:grid}
  .panel{background:#fff;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,.35);padding:16px 16px 12px;max-width:520px;width:min(92vw,520px)}
  .panel h2{margin:.2rem 0 .6rem;font-size:22px}
  .field{display:flex;gap:8px;margin:8px 0}
  .field input{flex:1;padding:10px 12px;border:2px solid #cfd7ea;border-radius:10px;font-size:16px}
  .rowBetween{display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap}
  .mt8{margin-top:8px}
  .list{max-height:320px;overflow:auto;border:2px solid #eef3ff;border-radius:10px}
  .rowItem{display:flex;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #eef3ff}
  .rowItem:last-child{border-bottom:0}
  .small{opacity:.75;font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="900" height="520"></canvas>

  <div class="hud">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Best: <span id="best">0</span></div>
    <button id="restart" class="pill btn">Restart</button>
    <button id="openBoard" class="pill btn">Leaderboard</button>
  </div>
</div>

<!-- Submit Score Modal -->
<div id="scoreModal" class="modal" aria-hidden="true">
  <div class="panel" role="dialog" aria-modal="true">
    <h2>Submit your score?</h2>
    <p class="small">Your run: <b id="modalScore">0</b></p>
    <div class="field">
      <input id="nameInput" type="text" placeholder="Your name (e.g., Alex)" maxlength="40" />
    </div>
    <div class="field">
      <input id="placeInput" type="text" placeholder="Where you live (City, Country)" maxlength="60" />
    </div>
    <div class="rowBetween mt8">
      <button id="skipSubmit" class="pill btn">No Thanks</button>
      <button id="submitBtn" class="pill btn">Submit Score</button>
    </div>
    <p id="submitMsg" class="small mt8"></p>
  </div>
</div>

<!-- Leaderboard Modal -->
<div id="boardModal" class="modal" aria-hidden="true">
  <div class="panel" role="dialog" aria-modal="true">
    <h2>Around-the-World Leaderboard</h2>
    <div id="boardList" class="list mt8"></div>
    <div class="rowBetween mt8">
      <button id="refreshBoard" class="pill btn">Refresh</button>
      <button id="closeBoard" class="pill btn">Close</button>
    </div>
    <p class="small mt8">Top 20 global scores (via Supabase). We also keep a local backup for offline play.</p>
  </div>
</div>

<script>
(() => {
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const restartBtn = document.getElementById('restart');

  // ===== Supabase config (PASTE YOUR VALUES) =====
  const SUPABASE_URL = "https://neiajkinanethteyoagr.supabase.co";   // URL
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5laWFqa2luYW5ldGh0ZXlvYWdyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwMjU0MzcsImV4cCI6MjA3NDYwMTQzN30.aEzoTrCyYOMCnqJ8hLKsaqPeUEoxPecAjKPQMleKH0A";                 // API
  const usingCloud = !!(SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL.startsWith('https://'));

  // Cloud helpers (using Supabase REST)
  async function postScore(name, place, score){
    if(!usingCloud) return null;
    const res = await fetch(`${SUPABASE_URL}/rest/v1/scores`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Prefer': 'return=representation'
      },
      body: JSON.stringify([{ name, place, score }])
    });
    if(!res.ok){
      const txt = await res.text().catch(()=>res.statusText);
      throw new Error(`Supabase insert failed: ${txt}`);
    }
    return (await res.json())?.[0] || null;
  }
  async function fetchTop(){
    if(!usingCloud) return [];
    const res = await fetch(
      `${SUPABASE_URL}/rest/v1/scores?select=name,place,score,created_at&order=score.desc&limit=20`, {
      headers: {
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
      }
    });
    if(!res.ok){
      const txt = await res.text().catch(()=>res.statusText);
      throw new Error(`Supabase fetch failed: ${txt}`);
    }
    return await res.json();
  }

  // Modals + fields
  const scoreModal = document.getElementById('scoreModal');
  const modalScore = document.getElementById('modalScore');
  const nameInput  = document.getElementById('nameInput');
  const placeInput = document.getElementById('placeInput');
  const submitBtn  = document.getElementById('submitBtn');
  const skipSubmit = document.getElementById('skipSubmit');
  const submitMsg  = document.getElementById('submitMsg');

  const boardModal = document.getElementById('boardModal');
  const openBoard  = document.getElementById('openBoard');
  const closeBoard = document.getElementById('closeBoard');
  const refreshBoard = document.getElementById('refreshBoard');
  const boardList  = document.getElementById('boardList');

  // ---------- sizing ----------
  let W=900, H=520, GY=H-80, DPR=1;
  function resize(){
    const dpr = Math.max(1, Math.min(window.devicePixelRatio||1, 3));
    DPR=dpr;
    const cssW = Math.min(window.innerWidth, 900);
    const cssH = Math.min(Math.max(window.innerHeight*0.70, 360), 520);
    cvs.style.width = cssW+'px';
    cvs.style.height= cssH+'px';
    cvs.width  = Math.floor(cssW*dpr);
    cvs.height = Math.floor(cssH*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W=cssW; H=cssH;
    GY = Math.floor(H*0.80);
    player.y = GY - player.h;
  }
  window.addEventListener('resize', resize);

  // ---------- pacing ----------
  const START_SPEED = 220; // px/s
  const MAX_SPEED   = 520; // cap
  const ACCEL_PPS2  = 30;  // px/s^2
  let tSinceStart = 0;

  // ---------- player / physics ----------
  const player = { x:120, y:0, w:40, h:40, vy:0, onGround:true, jumpHeld:false, jumpTime:0 };
  const GRAV=1800, JUMP_VY=-650, HOLD_ACC=-1400, HOLD_TIME=0.18;

  // ---------- obstacles ----------
  const obs = [];
  function spawn(){
    const width  = 40 + Math.random()*40;   // 40–80
    const height = 30 + Math.random()*40;   // 30–70

    const baseMin = 360, baseMax = 500;
    const extraMin = Math.max(0, (speed - START_SPEED) * 0.25);
    const extraMax = Math.max(0, (speed - START_SPEED) * 0.35);
    const gapMin = baseMin + extraMin;
    const gapMax = baseMax + extraMax;

    const lastX = obs.length ? obs[obs.length-1].x : (W + 200);
    const x = lastX + gapMin + Math.random()*(gapMax-gapMin);
    obs.push({ x, y: GY - height, w: width, h: height });
  }

  // ---------- input ----------
  let jumpPressed=false;
  function press(){ if(!player.jumpHeld){ jumpPressed=true; } player.jumpHeld=true; }
  function release(){ player.jumpHeld=false; }
  window.addEventListener('keydown', e => { if(e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); press(); }});
  window.addEventListener('keyup',   e => { if(e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); release(); }});
  cvs.addEventListener('pointerdown', e => { e.preventDefault(); press(); });
  cvs.addEventListener('pointerup',   e => { e.preventDefault(); release(); });

  // ---------- game state ----------
  let running=false, last=0, speed=START_SPEED, score=0, best=+(localStorage.simple_best||0);
  let dist=0;
  bestEl.textContent = best;

  function start(){
    resize();
    running=true; last=performance.now();
    speed=START_SPEED; score=0; dist=0; tSinceStart=0;
    Object.assign(player,{ x:120, y:GY-40, vy:0, onGround:true, jumpHeld:false, jumpTime:0 });
    obs.length=0; for(let i=0;i<6;i++) spawn();
    requestAnimationFrame(loop);
  }
  restartBtn.addEventListener('click', start);

  // ---------- loop ----------
  function loop(t){
    if(!running) return;
    const dt=Math.min(0.033,(t-last)/1000); last=t;
    update(dt); draw();
    requestAnimationFrame(loop);
  }

  function end(){
    running=false;
    if(score>best){ best=score; localStorage.simple_best=best; bestEl.textContent=best; }
    modalScore.textContent = score;
    submitMsg.textContent = '';
    nameInput.value = localStorage.player_name || '';
    placeInput.value = localStorage.player_place || '';
    scoreModal.classList.add('show');
    scoreModal.setAttribute('aria-hidden','false');
  }

  // ---------- local fallback leaderboard ----------
  function getBoard(){ try{ return JSON.parse(localStorage.simple_board||'[]'); }catch(_){ return []; } }
  function setBoard(rows){ localStorage.simple_board = JSON.stringify(rows); }
  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[m])); }

  async function showLeaderboard(){
    try{
      let rows = usingCloud ? await fetchTop() : null;
      if(!rows || !rows.length){
        rows = getBoard().sort((a,b)=>b.score-a.score).slice(0,20);
      }
      boardList.innerHTML = rows.length
        ? rows.map((r,i)=>`<div class="rowItem"><span>#${i+1} — ${escapeHtml(r.name)} <span class="small">(${escapeHtml(r.place)})</span></span><span>${(r.score|0)}</span></div>`).join('')
        : '<div class="rowItem"><span>No scores yet.</span><span>—</span></div>';
    }catch(e){
      const rows = getBoard().sort((a,b)=>b.score-a.score).slice(0,20);
      boardList.innerHTML = rows.length
        ? rows.map((r,i)=>`<div class="rowItem"><span>#${i+1} — ${escapeHtml(r.name)} <span class="small">(${escapeHtml(r.place)})</span></span><span>${(r.score|0)}</span></div>`).join('')
        : '<div class="rowItem"><span>No scores yet.</span><span>—</span></div>';
    }
  }

  // Submit score — cloud first, local fallback
  submitBtn.addEventListener('click', async () => {
    const name = (nameInput.value||'').trim();
    const place= (placeInput.value||'').trim();
    if(name.length<1 || place.length<2){
      submitMsg.textContent='Please add your name and where you live (e.g., City, Country).';
      return;
    }
    localStorage.player_name = name;
    localStorage.player_place = place;

    try{
      if(usingCloud){ await postScore(name, place, score); submitMsg.textContent='Saved to global leaderboard! 🎉'; }
    }catch(err){
      submitMsg.textContent='Online save failed; saved locally only.'; console.warn(err);
    }

    // Always keep local copy
    const rows = getBoard(); rows.push({name, place, score, date:new Date().toISOString()}); setBoard(rows);

    scoreModal.classList.remove('show'); scoreModal.setAttribute('aria-hidden','true');
    await showLeaderboard();
    boardModal.classList.add('show'); boardModal.setAttribute('aria-hidden','false');
    setTimeout(start, 300);
  });

  skipSubmit.addEventListener('click', () => {
    scoreModal.classList.remove('show'); scoreModal.setAttribute('aria-hidden','true');
    setTimeout(start, 300);
  });

  openBoard.addEventListener('click', () => { boardModal.classList.add('show'); boardModal.setAttribute('aria-hidden','false'); showLeaderboard(); });
  closeBoard.addEventListener('click', () => { boardModal.classList.remove('show'); boardModal.setAttribute('aria-hidden','true'); });
  refreshBoard.addEventListener('click', showLeaderboard);

  // ---------- FOX DRAWING HELPER ----------
  // Improved sticker-style fox with tilt, tail tip, inner ear, paw caps, tiny mouth
function drawFox(ctx, x, y, w, h, vy, onGround, groundY){
  const t = performance.now() / 1000;

  // running cycle (0..1) and subtle air tilt/squash
  const run = onGround ? (Math.sin(t*12)*0.5 + 0.5) : 0.5;
  const tilt = Math.max(-0.18, Math.min(0.18, -vy/1800)); // tilt nose up when rising
  const stretch = onGround ? 1 - Math.min(0.06, Math.abs(vy)*0.00005) : 1 + Math.min(0.07, Math.abs(vy)*0.00006);
  const squishX = 1 / stretch;

  // local transform so rotate/squash affects all parts
  ctx.save();
  ctx.translate(x + w*0.5, y + h*0.55);
  ctx.rotate(tilt);
  ctx.scale(squishX, stretch);
  ctx.translate(-w*0.5, -h*0.55);

  // shadow (outside the transform so it doesn't tilt)
  ctx.save();
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = '#2a6b46';
  ctx.beginPath();
  const shW = w * (onGround ? 0.95 : 0.75);
  const shH = h * 0.28;
  ctx.ellipse(x + w*0.5, groundY + 7, shW, shH, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // helper to draw sticker shapes
  function sticker(path, fill, ink='#172133', edge='#fff'){
    ctx.save();
    ctx.lineJoin = ctx.lineCap = 'round';
    // white edge
    ctx.lineWidth = Math.max(2, w*0.095);
    ctx.strokeStyle = edge;
    ctx.beginPath(); path(); ctx.stroke();
    // ink line
    ctx.lineWidth = Math.max(1.6, w*0.032);
    ctx.strokeStyle = ink;
    ctx.beginPath(); path(); ctx.stroke();
    // fill
    ctx.fillStyle = fill;
    ctx.beginPath(); path(); ctx.fill();
    ctx.restore();
  }

  // --- Tail (with white tip and a little wag when running) ---
  sticker(() => {
    const wag = 0.05*Math.sin(t*8);
    ctx.moveTo(w*0.18, h*0.66);
    ctx.quadraticCurveTo(w*(0.02+wag), h*(0.52+wag), w*0.10, h*(0.30));
    ctx.quadraticCurveTo(w*0.36, h*0.32, w*0.44, h*0.58);
    ctx.closePath();
  }, '#ff6b2f');
  // tail tip (white)
  ctx.save();
  ctx.fillStyle = '#ffe7d1';
  ctx.beginPath();
  ctx.moveTo(w*0.11, h*0.33);
  ctx.quadraticCurveTo(w*0.20, h*0.38, w*0.19, h*0.52);
  ctx.quadraticCurveTo(w*0.15, h*0.53, w*0.10, h*0.42);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // --- Body (slightly longer) ---
  sticker(() => {
    const r = w*0.12;
    const bx = w*0.18, by = h*0.28, bw = w*0.55, bh = h*0.46;
    ctx.moveTo(bx+r, by);
    ctx.lineTo(bx+bw-r, by); ctx.quadraticCurveTo(bx+bw, by, bx+bw, by+r);
    ctx.lineTo(bx+bw, by+bh-r); ctx.quadraticCurveTo(bx+bw, by+bh, bx+bw-r, by+bh);
    ctx.lineTo(bx+r, by+bh); ctx.quadraticCurveTo(bx, by+bh, bx, by+bh-r);
    ctx.lineTo(bx, by+r); ctx.quadraticCurveTo(bx, by, bx+r, by);
    ctx.closePath();
  }, '#ff6b2f');

  // belly patch
  ctx.save();
  ctx.fillStyle = '#ffe7d1';
  ctx.beginPath();
  ctx.ellipse(w*0.44, h*0.58, w*0.18, h*0.18, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // --- Head with inner ear ---
  sticker(() => {
    const hx = w*0.60, hy = h*0.16, hw = w*0.36, hh = h*0.36, r = w*0.10;
    // head
    ctx.moveTo(hx+r, hy);
    ctx.lineTo(hx+hw-r, hy); ctx.quadraticCurveTo(hx+hw, hy, hx+hw, hy+r);
    ctx.lineTo(hx+hw, hy+hh-r); ctx.quadraticCurveTo(hx+hw, hy+hh, hx+hw-r, hy+hh);
    ctx.lineTo(hx+r, hy+hh); ctx.quadraticCurveTo(hx, hy+hh, hx, hy+hh-r);
    ctx.lineTo(hx, hy+r); ctx.quadraticCurveTo(hx, hy, hx+r, hy);
    // big ear
    ctx.moveTo(hx+hw*0.55, hy);
    ctx.lineTo(hx+hw*0.82, hy - h*0.12);
    ctx.lineTo(hx+hw*0.72, hy + h*0.08);
    ctx.closePath();
  }, '#ff6b2f');

  // inner ear (light)
  ctx.save();
  ctx.fillStyle = '#ffd3b0';
  ctx.beginPath();
  const hx = w*0.60, hy = h*0.16, hw = w*0.36;
  ctx.moveTo(hx+hw*0.60, hy - h*0.01);
  ctx.lineTo(hx+hw*0.78, hy - h*0.09);
  ctx.lineTo(hx+hw*0.70, hy + h*0.05);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // muzzle (white) + tiny mouth
  ctx.save();
  ctx.fillStyle = '#ffe7d1';
  ctx.beginPath();
  ctx.ellipse(w*0.87, h*0.44, w*0.07, h*0.06, 0, 0, Math.PI*2);
  ctx.fill();
  // mouth
  ctx.strokeStyle = '#172133';
  ctx.lineWidth = Math.max(1.2, w*0.02);
  ctx.beginPath();
  ctx.moveTo(w*0.90, h*0.47);
  ctx.quadraticCurveTo(w*0.92, h*0.50, w*0.94, h*0.48);
  ctx.stroke();
  ctx.restore();

  // eye with specular dot + nose
  ctx.save();
  ctx.fillStyle = '#172133';
  ctx.beginPath(); ctx.arc(w*0.73, h*0.38, Math.max(1.6, w*0.03), 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(w*0.725, h*0.37, Math.max(0.8, w*0.012), 0, Math.PI*2); ctx.fill(); // eye highlight
  ctx.fillStyle = '#172133';
  ctx.beginPath(); ctx.arc(w*0.92, h*0.44, Math.max(1.7, w*0.028), 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // legs with depth (rear darker), paw caps
  const legCycleA = h*(0.40 + 0.10*run);
  const legCycleB = h*(0.40 + 0.10*(1-run));
  // rear leg
  ctx.save();
  ctx.fillStyle = '#0f1829';
  ctx.fillRect(w*0.28, h*0.60, w*0.12, legCycleA*0.46);
  ctx.fillStyle = '#ffe7d1';
  ctx.fillRect(w*0.28, h*0.60 + legCycleA*0.46 - h*0.05, w*0.12, h*0.05);
  ctx.restore();
  // front leg
  ctx.save();
  ctx.fillStyle = '#172133';
  ctx.fillRect(w*0.48, h*0.60, w*0.12, legCycleB*0.46);
  ctx.fillStyle = '#ffe7d1';
  ctx.fillRect(w*0.48, h*0.60 + legCycleB*0.46 - h*0.05, w*0.12, h*0.05);
  ctx.restore();

  ctx.restore(); // end local transform
}

  // ---------- update/draw ----------
  function update(dt){
    tSinceStart += dt;
    const ease = Math.min(1, tSinceStart / 1.0);
    speed += (ACCEL_PPS2 * ease) * dt;
    if (speed > MAX_SPEED) speed = MAX_SPEED;

    dist  += speed * dt;
    score = Math.max(0, Math.floor(dist / 60));
    scoreEl.textContent = score;

    for(const o of obs){ o.x -= speed*dt; }
    if(obs.length && obs[0].x + obs[0].w < -10) obs.shift();
    if(!obs.length || obs[obs.length-1].x < W + 160) spawn();

    if(jumpPressed && player.onGround){
      player.vy = JUMP_VY; player.onGround=false; player.jumpTime=0;
    }
    jumpPressed=false;

    if(player.jumpHeld && player.vy<0){
      player.jumpTime += dt;
      const k = Math.max(0, 1 - player.jumpTime/HOLD_TIME);
      player.vy += HOLD_ACC * dt * k;
    }

    player.vy += GRAV*dt;
    player.y  += player.vy*dt;

    if(player.y + player.h >= GY){
      player.y = GY - player.h;
      if(!player.onGround){ player.onGround=true; player.vy=0; }
    }

    for(const o of obs){
      if(player.x < o.x+o.w && player.x+player.w > o.x && player.y < o.y+o.h && player.y+player.h > o.y){
        end(); return;
      }
    }
  }

  function draw(){
    // background
    ctx.fillStyle = '#bfe6ff'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#3aa655'; ctx.fillRect(0,GY,W,H-GY);

    // FOX (replaces the old orange box)
    drawFox(ctx, player.x, player.y, player.w, player.h, player.vy, player.onGround, GY);

    // obstacles
    ctx.fillStyle = '#654321';
    for(const o of obs){ ctx.fillRect(o.x, o.y, o.w, o.h); }
  }

  // boot
  start();
})();
</script>
</body>
</html>
